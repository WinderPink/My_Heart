<!-- <!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Beating Heart</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>

    <canvas id="heartCanvas"></canvas>

    <script>
        const canvas = document.getElementById('heartCanvas');
        const ctx = canvas.getContext('2d');

        // Cấu hình tương tự Python
        const CANVAS_WIDTH = 640;
        const CANVAS_HEIGHT = 640;
        const CANVAS_CENTER_X = CANVAS_WIDTH / 2;
        const CANVAS_CENTER_Y = CANVAS_HEIGHT / 2 - 90;
        const IMAGE_ENLARGE = 11;
        const HEART_COLOR = "#f76070";

        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // Hàm toán học tạo hình trái tim
        function heart_function(t, shrink_ratio = IMAGE_ENLARGE) {
            let x = 16 * Math.pow(Math.sin(t), 3);
            let y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));

            x *= shrink_ratio;
            y *= shrink_ratio;

            x += CANVAS_CENTER_X;
            y += CANVAS_CENTER_Y;

            return { x: Math.floor(x), y: Math.floor(y) };
        }

        function scatter_inside(x, y, beta = 0.15) {
            let ratio_x = -beta * Math.log(Math.random());
            let ratio_y = -beta * Math.log(Math.random());

            let dx = ratio_x * (x - CANVAS_CENTER_X);
            let dy = ratio_y * (y - CANVAS_CENTER_Y);

            return { x: x - dx, y: y - dy };
        }

        function shrink(x, y, ratio) {
            let force = -1 / Math.pow(Math.pow(x - CANVAS_CENTER_X, 2) + Math.pow(y - CANVAS_CENTER_Y, 2), 0.6);
            let dx = ratio * force * (x - CANVAS_CENTER_X);
            let dy = ratio * force * (y - CANVAS_CENTER_Y);
            return { x: x - dx, y: y - dy };
        }

        function curve(p) {
            return 2 * (2 * Math.sin(4 * p)) / (2 * Math.PI);
        }

        class Swirl {
            constructor() {
                this.particles = [];
                this.count = 2500; // Số lượng hạt trắng
                for (let i = 0; i < this.count; i++) {
                    this.particles.push(this.resetParticle());
                }
            }

            resetParticle() {
                return {
                    angle: Math.random() * Math.PI * 2,
                    radius: Math.random() * 5,
                    speed: 0.02 + Math.random() * 0.05,
                    rSpeed: 1 + Math.random() * 1.5,
                    opacity: Math.random(),
                    size: 0.5 + Math.random() * 1.5
                };
            }

            updateAndDraw() {
                ctx.fillStyle = "white";
                this.particles.forEach(p => {
                    p.angle += p.speed;
                    p.radius += p.rSpeed;
                    
                    // Tạo hình elip cho vòng xoáy
                    let x = CANVAS_CENTER_X + Math.cos(p.angle) * p.radius;
                    let y = (CANVAS_CENTER_Y + 90 + 130) + Math.sin(p.angle) * (p.radius * 0.25);

                    ctx.globalAlpha = p.opacity;
                    ctx.fillRect(x, y, p.size, p.size);

                    // Reset hạt khi bay quá xa hoặc mờ dần
                    if (p.radius > 250) {
                        Object.assign(p, this.resetParticle());
                    }
                });
                ctx.globalAlpha = 1.0;
                ctx.fillStyle = "rgba(0, 0, 0, 0.15)"; 
            }
        }

        class Heart {
            constructor(generate_frame = 20) {
                this.points = [];
                this.edge_diffusion_points = [];
                this.center_diffusion_points = [];
                this.all_points = {};
                this.generate_frame = generate_frame;

                this.build(2000);

                for (let frame = 0; frame < generate_frame; frame++) {
                    this.calc(frame);
                }
            }

            build(number) {
                for (let i = 0; i < number; i++) {
                    let t = Math.random() * 2 * Math.PI;
                    let pos = heart_function(t);
                    this.points.push([pos.x, pos.y]);
                }

                this.points.forEach(([px, py]) => {
                    for (let i = 0; i < 3; i++) {
                        let pos = scatter_inside(px, py, 0.05);
                        this.edge_diffusion_points.push([pos.x, pos.y]);
                    }
                });

                for (let i = 0; i < 4000; i++) {
                    let randIdx = Math.floor(Math.random() * this.points.length);
                    let [px, py] = this.points[randIdx];
                    let pos = scatter_inside(px, py, 0.17);
                    this.center_diffusion_points.push([pos.x, pos.y]);
                }
            }

            calc_position(x, y, ratio) {
                let force = 1 / Math.pow(Math.pow(x - CANVAS_CENTER_X, 2) + Math.pow(y - CANVAS_CENTER_Y, 2), 0.520);
                let dx = ratio * force * (x - CANVAS_CENTER_X) + (Math.floor(Math.random() * 3) - 1);
                let dy = ratio * force * (y - CANVAS_CENTER_Y) + (Math.floor(Math.random() * 3) - 1);
                return { x: x - dx, y: y - dy };
            }

            calc(frame) {
                let ratio = 10 * curve((frame / 10) * Math.PI);
                let halo_radius = Math.floor(4 + 6 * (1 + curve((frame / 10) * Math.PI)));
                let halo_number = Math.floor(3000 + 4000 * Math.abs(Math.pow(curve((frame / 10) * Math.PI), 2)));

                let frame_points = [];

                // Halo
                let heart_halo_point = new Set();
                for (let i = 0; i < halo_number; i++) {
                    let t = Math.random() * 2 * Math.PI;
                    let pos = heart_function(t, 11.6);
                    let shrink_pos = shrink(pos.x, pos.y, halo_radius);
                    let key = `${Math.floor(shrink_pos.x)},${Math.floor(shrink_pos.y)}`;
                    
                    if (!heart_halo_point.has(key)) {
                        heart_halo_point.add(key);
                        let x = shrink_pos.x + (Math.floor(Math.random() * 29) - 14);
                        let y = shrink_pos.y + (Math.floor(Math.random() * 29) - 14);
                        let size = Math.random() < 0.33 ? 1 : 2;
                        frame_points.push([x, y, size]);
                    }
                }

                // Các điểm chính
                this.points.forEach(([x, y]) => {
                    let pos = this.calc_position(x, y, ratio);
                    let size = Math.floor(Math.random() * 3) + 1;
                    frame_points.push([pos.x, pos.y, size]);
                });

                this.edge_diffusion_points.forEach(([x, y]) => {
                    let pos = this.calc_position(x, y, ratio);
                    let size = Math.floor(Math.random() * 2) + 1;
                    frame_points.push([pos.x, pos.y, size]);
                });

                this.center_diffusion_points.forEach(([x, y]) => {
                    let pos = this.calc_position(x, y, ratio);
                    let size = Math.floor(Math.random() * 2) + 1;
                    frame_points.push([pos.x, pos.y, size]);
                });

                this.all_points[frame] = frame_points;
            }

            render(frame) {
                let points = this.all_points[frame % this.generate_frame];
                ctx.fillStyle = HEART_COLOR;
                points.forEach(([x, y, size]) => {
                    ctx.fillRect(x, y, size, size);
                });
            }
        }

        const heart = new Heart();
        const swirl = new Swirl();
        let currentFrame = 0;

        function draw() {

            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            swirl.updateAndDraw();
            heart.render(currentFrame);
            
            currentFrame++;
            setTimeout(() => {
                requestAnimationFrame(draw);
            }, 130); 
        }

        draw();
    </script>
</body>
</html> -->


<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Beating Heart</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>

    <canvas id="heartCanvas"></canvas>

    <script>
        const canvas = document.getElementById('heartCanvas');
        const ctx = canvas.getContext('2d');

        // Cấu hình tương tự Python
        const CANVAS_WIDTH = 640;
        const CANVAS_HEIGHT = 640;
        const CANVAS_CENTER_X = CANVAS_WIDTH / 2;
        const CANVAS_CENTER_Y = CANVAS_HEIGHT / 2 - 90;
        const IMAGE_ENLARGE = 11;
        const HEART_COLOR = "#f76070";

        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // Hàm toán học tạo hình trái tim
        function heart_function(t, shrink_ratio = IMAGE_ENLARGE) {
            let x = 16 * Math.pow(Math.sin(t), 3);
            let y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));

            x *= shrink_ratio;
            y *= shrink_ratio;

            x += CANVAS_CENTER_X;
            y += CANVAS_CENTER_Y;

            return { x: Math.floor(x), y: Math.floor(y) };
        }

        function scatter_inside(x, y, beta = 0.15) {
            let ratio_x = -beta * Math.log(Math.random());
            let ratio_y = -beta * Math.log(Math.random());

            let dx = ratio_x * (x - CANVAS_CENTER_X);
            let dy = ratio_y * (y - CANVAS_CENTER_Y);

            return { x: x - dx, y: y - dy };
        }

        function shrink(x, y, ratio) {
            let force = -1 / Math.pow(Math.pow(x - CANVAS_CENTER_X, 2) + Math.pow(y - CANVAS_CENTER_Y, 2), 0.6);
            let dx = ratio * force * (x - CANVAS_CENTER_X);
            let dy = ratio * force * (y - CANVAS_CENTER_Y);
            return { x: x - dx, y: y - dy };
        }

        function curve(p) {
            return 2 * (2 * Math.sin(4 * p)) / (2 * Math.PI);
        }

        class Swirl {
            constructor() {
                this.particles = [];
                this.count = 2500; // Số lượng hạt trắng
                for (let i = 0; i < this.count; i++) {
                    this.particles.push(this.resetParticle());
                }
            }

            resetParticle() {
                return {
                    angle: Math.random() * Math.PI * 2,
                    radius: Math.random() * 5,
                    speed: 0.02 + Math.random() * 0.05,
                    rSpeed: 1 + Math.random() * 1.5,
                    opacity: Math.random(),
                    size: 0.5 + Math.random() * 1.5
                };
            }

            updateAndDraw() {
                ctx.fillStyle = "white";
                this.particles.forEach(p => {
                    p.angle += p.speed;
                    p.radius += p.rSpeed;
                    
                    // Tạo hình elip cho vòng xoáy
                    let x = CANVAS_CENTER_X + Math.cos(p.angle) * p.radius;
                    let y = (CANVAS_CENTER_Y + 90 + 130) + Math.sin(p.angle) * (p.radius * 0.25);

                    ctx.globalAlpha = p.opacity;
                    ctx.fillRect(x, y, p.size, p.size);

                    // Reset hạt khi bay quá xa hoặc mờ dần
                    if (p.radius > 250) {
                        Object.assign(p, this.resetParticle());
                    }
                });
                ctx.globalAlpha = 1.0;
                ctx.fillStyle = "rgba(0, 0, 0, 0.15)"; 
            }
        }

        class Heart {
            constructor(generate_frame = 20) {
                this.points = [];
                this.edge_diffusion_points = [];
                this.center_diffusion_points = [];
                this.all_points = {};
                this.generate_frame = generate_frame;

                this.build(2000);

                for (let frame = 0; frame < generate_frame; frame++) {
                    this.calc(frame);
                }
            }

            build(number) {
                for (let i = 0; i < number; i++) {
                    let t = Math.random() * 2 * Math.PI;
                    let pos = heart_function(t);
                    this.points.push([pos.x, pos.y]);
                }

                this.points.forEach(([px, py]) => {
                    for (let i = 0; i < 3; i++) {
                        let pos = scatter_inside(px, py, 0.05);
                        this.edge_diffusion_points.push([pos.x, pos.y]);
                    }
                });

                for (let i = 0; i < 4000; i++) {
                    let randIdx = Math.floor(Math.random() * this.points.length);
                    let [px, py] = this.points[randIdx];
                    let pos = scatter_inside(px, py, 0.17);
                    this.center_diffusion_points.push([pos.x, pos.y]);
                }
            }

            calc_position(x, y, ratio) {
                let force = 1 / Math.pow(Math.pow(x - CANVAS_CENTER_X, 2) + Math.pow(y - CANVAS_CENTER_Y, 2), 0.520);
                let dx = ratio * force * (x - CANVAS_CENTER_X) + (Math.floor(Math.random() * 3) - 1);
                let dy = ratio * force * (y - CANVAS_CENTER_Y) + (Math.floor(Math.random() * 3) - 1);
                return { x: x - dx, y: y - dy };
            }

            calc(frame) {
                let ratio = 10 * curve((frame / 10) * Math.PI);
                let halo_radius = Math.floor(4 + 6 * (1 + curve((frame / 10) * Math.PI)));
                let halo_number = Math.floor(3000 + 4000 * Math.abs(Math.pow(curve((frame / 10) * Math.PI), 2)));

                let frame_points = [];

                // Halo
                let heart_halo_point = new Set();
                for (let i = 0; i < halo_number; i++) {
                    let t = Math.random() * 2 * Math.PI;
                    let pos = heart_function(t, 11.6);
                    let shrink_pos = shrink(pos.x, pos.y, halo_radius);
                    let key = `${Math.floor(shrink_pos.x)},${Math.floor(shrink_pos.y)}`;
                    
                    if (!heart_halo_point.has(key)) {
                        heart_halo_point.add(key);
                        let x = shrink_pos.x + (Math.floor(Math.random() * 29) - 14);
                        let y = shrink_pos.y + (Math.floor(Math.random() * 29) - 14);
                        let size = Math.random() < 0.33 ? 1 : 2;
                        frame_points.push([x, y, size]);
                    }
                }

                // Các điểm chính
                this.points.forEach(([x, y]) => {
                    let pos = this.calc_position(x, y, ratio);
                    let size = Math.floor(Math.random() * 3) + 1;
                    frame_points.push([pos.x, pos.y, size]);
                });

                this.edge_diffusion_points.forEach(([x, y]) => {
                    let pos = this.calc_position(x, y, ratio);
                    let size = Math.floor(Math.random() * 2) + 1;
                    frame_points.push([pos.x, pos.y, size]);
                });

                this.center_diffusion_points.forEach(([x, y]) => {
                    let pos = this.calc_position(x, y, ratio);
                    let size = Math.floor(Math.random() * 2) + 1;
                    frame_points.push([pos.x, pos.y, size]);
                });

                this.all_points[frame] = frame_points;
            }

            render(frame) {
                let points = this.all_points[frame % this.generate_frame];
                ctx.fillStyle = HEART_COLOR;
                points.forEach(([x, y, size]) => {
                    ctx.fillRect(x, y, size, size);
                });
            }
        }

        const heart = new Heart();
        const swirl = new Swirl();
        let currentFrame = 0;

        function draw() {

            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            swirl.updateAndDraw();
            heart.render(currentFrame);
            
            currentFrame++;
            setTimeout(() => {
                requestAnimationFrame(draw);
            }, 130); 
        }

        draw();

        window.addEventListener('resize', () => {
            location.reload(); 
        });

    </script>
</body>
</html>